<!-- docs/math/04-data-structures.html -->
<section class="chapter" id="04-data-structures">
    <h2 id="4-data-structures">4. データ構造と<ruby>演算効率<rt>えんざんこうりつ</rt></ruby></h2>
    <div class="para">
        数独解読の実装効率を根本的に規定するのは、候補集合および制約状態の表現方法である。推論規則や探索戦略の理論的優劣も、実装上の表現形式によって大きく性能が変化するため、この層の設計は単なる実装技法にとどまらず、アルゴリズム工学的な研究対象として重要である。最も有効な表現形式は ビットマスク表現である。各セル $(r,c)$ の候補集合を 9 ビット整数として符号化し、第 $d$ ビットが 1 であるとき、そのセルが数字 $d$ を候補として許容していると解釈する。例えば候補が $\{1,3,9\}$ の場合、そのビット列は $100000101_2$
        に対応する。この表現を採用することで、候補削減や候補数の計算は低レベルなビット演算に帰着する。具体的には `AND`, `OR`, `XOR` による集合操作、`popcount` による候補数計算などが定数時間で処理できる。すなわち、制約伝播の核心処理をアルゴリズム的に $O(1)$ に収束させることができる。行・列・ブロックごとの使用済み数字の管理も同様に 9 ビット整数で表現できる。あるセルの候補から行・列・ブロックで既に使用済みの数字を排除する操作は

        $$C_{r,c} \leftarrow C_{r,c} \setminus \{d \mid d \in \text{row}(r) \cup \text{col}(c) \cup \text{box}(b)\}$$

        に対応し、ビットマスクの単純な除去演算として一括で実行できる。Python のような高水準言語であっても、整数に対するビット演算は極めて高速であり、C 言語レベルの最適化を行わずとも十分に実用的な性能が得られる。すなわち、言語間の実装差はここではほとんど律速要因とならない。さらに洗練された設計として、盤面更新を 永続データ構造 (persistent data structure) として管理する方式がある。これは関数型プログラミングにおける参照透明性を基盤とする設計思想であり、盤面の各更新を差分として記録する。これにより undo/redo 操作は「差分参照の切り替え」として実現でき、任意の過去状態への遡及や分岐状態の保持を効率的に行える。データ構造的には、盤面を木構造や差分リストとして管理し、共有部分を再利用することでコピーコストを削減することができる。この仕組みは単に実装上の利便性にとどまらない。数独の解読過程はしばしば分岐探索と推論削減の反復からなり、複数の盤面状態を並行的に保持する必要がある。このとき永続データ構造を用いれば、バックトラック探索が参照透過的に実行可能となり、探索木全体を効率的に横断する基盤を提供する。すなわち、探索におけるノード遷移が「状態の破壊的変更」ではなく「差分付き状態の選択」として定式化されることにより、計算過程全体が理論的に明瞭かつ実装的に高効率となる。このように、候補集合のビットマスク表現と盤面の永続的管理は、数独アプリケーションの性能とユーザ体験を決定づける基盤である。演算効率の確立によって推論規則や探索戦略が実用的に機能し、差分管理によって人間にとって自然な操作（undo/redo や段階的解読の提示）が可能になる。データ構造と演算効率の設計は、数独解読システムを単なるパズル解法器から、理論的に整備された実験環境へと昇華させる鍵である。
    </div>
</section>