<!doctype html>
<html lang="ja" class="no-js">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数独Resolver</title>
    <meta name="color-scheme" content="light dark">
    <meta name="description" content="数独を有限領域制約充足問題 (CSP) として厳密に定式化し、推論・探索・可視化までを統合的に論じるドキュメント。">
    <link rel="canonical" href="https://5uog.github.io/SudokuResolver/">

    <!--=============== no-js → js 早期置換 ===============-->
    <script>
        (function () {
            var doc = document.documentElement;
            doc.classList.add('js');
            doc.classList.remove('no-js');
        })();
    </script>
    <style>
        .requires-js { display: none; }
        .js .requires-js { display: block; }
        .nojs-warning { display: none; }
        .no-js .nojs-warning { display: block; }
        .nojs-banner { position: fixed; inset: 0; display: grid; place-items: center; background: #0f1217; color: #eaeef2; padding: 24px; z-index: 99999; }
        .nojs-card { max-width: 720px; width: min(92vw, 720px); background: #1b1f27; border: 1px solid #2a2f3a; border-radius: 16px; padding: 24px 20px; box-shadow: 0 16px 48px rgba(0, 0, 0, .35); line-height: 1.6; }
        .nojs-card h1 { margin: 0 0 .4em; font-size: 1.25rem; }
        .nojs-actions { display: flex; gap: 12px; margin-top: 12px; flex-wrap: wrap; }
        .btn { appearance: none; border: 1px solid #3a4250; background: #0b5fff; color: #fff; padding: 10px 14px; border-radius: 10px; text-decoration: none; font-weight: 600; }
        .btn.secondary { background: transparent; color: #eaeef2; }
    </style>

    <!--=============== Loading Boot (paint-before) ===============-->
    <link rel="stylesheet" href="../styles/loading.css">

    <script>
        (function () {
            var doc = document.documentElement;
            doc.classList.add('boot-loading');

            document.write(
                '<div id="sr-loading" class="sr-loading sr-loading--boot" role="status" aria-live="polite">' +
                '<div class="sr-loading__inner">' +
                    '<div class="sr-loading__spinner" aria-hidden="true"></div>' +
                    '<p class="sr-loading__label">Loading…</p>' +
                '</div>' +
                '</div>'
            );

            requestAnimationFrame(function () {
                var el = document.getElementById('sr-loading');
                if (el) el.classList.add('is-entered');
            });
        })();
    </script>
    <style>
        .sr-loading{position:fixed;inset:0;display:grid;place-items:center;overflow:hidden;z-index:9999;
                    background:var(--sr-loading-bg,#0b0e14);color:#fff;opacity:1}
        .sr-loading__spinner{width:44px;height:44px;border-radius:50%;
                            border:4px solid rgba(255,255,255,.25);border-top-color:#fff;
                            animation:srspin 1s linear infinite}
        .sr-loading__label{margin-top:12px;font:600 14px/1.2 system-ui,Segoe UI,Roboto,Helvetica,Arial}
        @keyframes srspin{to{transform:rotate(360deg)}}
        .sr-loading.is-leaving{transition:opacity .28s ease;opacity:0}
        html.boot-loading, body.has-loading{overflow:hidden}
    </style>

    <!--=============== OGP / TWITTER ===============-->
    <meta property="og:type" content="website">
    <meta property="og:title" content="SudokuResolver Docs">
    <meta property="og:description" content="数独をCSPとして論じ、数理的基盤から実装・可視化までを解説する。">
    <meta property="og:url" content="https://5uog.github.io/SudokuResolver/">
    <meta property="og:image" content="https://5uog.github.io/SudokuResolver/assets/logo.png">
    <meta property="og:image:width" content="512">
    <meta property="og:image:height" content="512">
    <meta property="og:locale" content="ja_JP">
    <meta name="twitter:card" content="summary">

    <!--=============== FONTS ===============-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">

    <!--=============== FONTAWESOME ===============-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.2/css/all.min.css">

    <!--=============== REMIXICONS ===============-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.6.0/remixicon.min.css">

    <!--=============== SWIPER CSS ===============-->
    <link rel="stylesheet" href="./styles/modules/swiper-bundle.min.css">

    <!--=============== DESIGN TOKEN AND BASE ===============-->
    <link rel="stylesheet" href="./styles/tokens.css">
    <link rel="stylesheet" href="./styles/base.css">
    <link rel="stylesheet" href="./styles/blob.css">
    <link rel="stylesheet" href="./styles/header.css">
    <link rel="stylesheet" href="./styles/home.css">
    <link rel="stylesheet" href="./styles/button.css">
    <link rel="stylesheet" href="./styles/features.css">
    <link rel="stylesheet" href="./styles/faq.css">
    <link rel="stylesheet" href="./styles/approach.css">
    <link rel="stylesheet" href="./styles/footer.css">
    <link rel="stylesheet" href="./styles/scrollbar.css">
    <link rel="stylesheet" href="./styles/breakpoints.css">

    <!--=============== KATEX BASE CSS ===============-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <link rel="stylesheet" href="./styles/math.css">

    <!--=============== PRINTS ===============-->
    <link rel="stylesheet" href="./styles/print.css" media="print">

    <!--=============== KATEX CORE + AUTO RENDER ===============-->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
    
    <!--=============== SITE SCRIPTS (ALL FEATURES INIT) ===============-->
    <script type="module" src="js/index.js" defer></script>

    <!--=============== FAVICON + MANIFEST ===============-->
    <link rel="icon" href="./assets/favicon.ico">
    <link rel="apple-touch-icon" href="./assets/apple-touch-icon.png">
    <link rel="manifest" href="./assets/site.webmanifest">

    <script>
        (function () {
            try {
                var key = 'sudoku:theme';
                var saved = localStorage.getItem(key);
                var prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                var theme = (saved === 'light' || saved === 'dark') ? saved : (prefersDark ? 'dark' : 'light');
                if (theme === 'light') document.documentElement.setAttribute('data-theme', 'light');
                else if (theme === 'dark') document.documentElement.setAttribute('data-theme', 'dark');
            } catch (e) { }
        })();
    </script>
</head>

<body>
    <!-- 1) JS無効時だけ確実に出る警告（全画面オーバーレイ） -->
    <noscript>
        <div class="nojs-warning">
            <div class="nojs-banner">
                <div class="nojs-card" role="alert" aria-live="assertive">
                    <h1>JavaScript が無効です</h1>
                    <p>このサイトはテーマ切替・数式レンダリング・ナビゲーション等に JavaScript を利用しています。</p>
                    <p>お手数ですが、ブラウザ設定や拡張機能で JavaScript を有効にしてください。</p>
                    <div class="nojs-actions">
                        <a class="btn secondary" href="https://www.enable-javascript.com/ja/" target="_blank"
                            rel="noopener">有効化の方法</a>
                    </div>
                </div>
            </div>
        </div>
    </noscript>

    <!-- 2) ここから下の “JSが必要な本体” を .requires-js で包む -->
    <div class="requires-js">
        <!-- JS で勝手に追加してくれるが、予備的に header を追加しておく -->
        <div id="sr-topbar"></div>

        <main class="main">
            <section class="home section">
                <div class="home__shadow"></div>

                <div class="home__container container grid">
                    <div class="home__data">
                        <h3 class="home__catch">Meet</h3>
                        <h1 class="home__brand">Sudoku <br> Resolver</h1>
                    </div>
                    <div class="home__image">
                        <div class="blob-animate"></div>
                        <img src="assets/logo_.png" alt="image" class="home__logo">
                    </div>
                    <div class="home__feature">
                        <h3 class="feature__kicker">Solve</h3>
                        <h2 class="feature__title-1">Sudoku</h2>
                        <h2 class="feature__title-2">Puzzles</h2>
                    </div>
                    <div class="home__social">
                        <a href="https://github.com/5uog" target="_blank" class="home__social-link">
                            <i class="ri-github-line"></i>
                        </a>
                        <a href="https://soundcloud.com/suog" target="_blank" class="home__social-link">
                            <i class="ri-soundcloud-line"></i>
                        </a>
                    </div>
                    <a href="" download target="_blank" class="home__exe">
                        DOWNLOAD <i class="ri-windows-line"></i>
                    </a>
                </div>
            </section>

            <section class="features section" id="features">
                <h2 class="section__title">
                    特長と利点 <br>
                    <span>Features & Benefits</span>
                </h2>
                <div class="features__container container grid">
                    <div class="features__swiper swiper">
                        <div class="swiper-wrapper">
                            <article class="features__card swiper-slide">
                                <div class="blob"></div>

                                <div class="features__number">
                                    <h1>01</h1>
                                    <h3>直感的な操作性</h3>
                                </div>
                                <div class="features__data">
                                    <h1 class="features__title">Intuitive <br> Controls</h1>
                                    <p class="features__subtitle">複雑な準備を必要としない明快なUI設計。</p>
                                    <p class="features__description">メニュー構成は論理的に整理され、主要機能へは最短経路で到達可能です。マウスとキーボードの両方に配慮した操作体系により、学習コストを最小限に抑えます。</p>
                                </div>

                                <div class="features__image">
                                    <img src="assets/features/unknown.png" alt="image" class="features__img">
                                    <a href="#" target="_blank" class="features__button">
                                        <i class="ri-arrow-right-up-long-line"></i>
                                    </a>
                                </div>
                            </article>

                            <article class="features__card swiper-slide">
                                <div class="blob"></div>

                                <div class="features__number">
                                    <h1>02</h1>
                                    <h3>洗練されたUI</h3>
                                </div>
                                <div class="features__data">
                                    <h1 class="features__title">Sleek <br> Interface</h1>
                                    <p class="features__subtitle">作業環境に自然に溶け込むデザイン。</p>
                                    <p class="features__description">明暗テーマに対応し、タイポグラフィや余白は可読性を最優先に設計。装飾は最小限に抑えつつ、学術的文書にも適合する落ち着いた外観を備えています。</p>
                                </div>

                                <div class="features__image">
                                    <img src="assets/features/unknown.png" alt="image" class="features__img">
                                    <a href="#" target="_blank" class="features__button">
                                        <i class="ri-arrow-right-up-long-line"></i>
                                    </a>
                                </div>
                            </article>

                            <article class="features__card swiper-slide">
                                <div class="blob"></div>

                                <div class="features__number">
                                    <h1>03</h1>
                                    <h3>充実した機能群</h3>
                                </div>
                                <div class="features__data">
                                    <h1 class="features__title">Comprehensive <br> Functions</h1>
                                    <p class="features__subtitle">実務から研究用途までを支える多層的な機能。</p>
                                    <p class="features__description">候補数字の自動更新、矛盾検出、段階的推論ログ、無制限のUndo/Redoなど、学習支援から検証作業まで幅広く対応します。</p>
                                </div>

                                <div class="features__image">
                                    <img src="assets/features/unknown.png" alt="image" class="features__img">
                                    <a href="#" target="_blank" class="features__button">
                                        <i class="ri-arrow-right-up-long-line"></i>
                                    </a>
                                </div>
                            </article>

                            <article class="features__card swiper-slide">
                                <div class="blob"></div>

                                <div class="features__number">
                                    <h1>04</h1>
                                    <h3>高速かつ安定</h3>
                                </div>
                                <div class="features__data">
                                    <h1 class="features__title">Performance <br> & Stability</h1>
                                    <p class="features__subtitle">演算効率と応答性を両立。</p>
                                    <p class="features__description">ネイティブ実装により遅延を最小化し、大規模な探索処理でも安定動作を維持。レスポンスは常に滑らかで、長時間の利用にも耐える堅牢な設計です。</p>
                                </div>

                                <div class="features__image">
                                    <img src="assets/features/unknown.png" alt="image" class="features__img">
                                    <a href="#" target="_blank" class="features__button">
                                        <i class="ri-arrow-right-up-long-line"></i>
                                    </a>
                                </div>
                            </article>
                            
                            <article class="features__card swiper-slide">
                                <div class="blob"></div>

                                <div class="features__number">
                                    <h1>05</h1>
                                    <h3>国際的な実績</h3>
                                </div>
                                <div class="features__data">
                                    <h1 class="features__title">Leaderboard <br> Achievement</h1>
                                    <p class="features__subtitle">Sudoku Now で首位を獲得。</p>
                                    <p class="features__description">2025年第35週、<strong>374,424点</strong>の記録でリーダーボード<strong>1位</strong>を達成。2位との差は約<strong>240,000点</strong>に及び、処理速度と正確性の双方において卓越した性能を立証しました。</p>
                                </div>

                                <div class="features__image">
                                    <img src="assets/features/05.png" alt="image" class="features__img">
                                    <a href="#" target="_blank" class="features__button">
                                        <i class="ri-arrow-right-up-long-line"></i>
                                    </a>
                                </div>
                            </article>
                        </div>

                        <div class="swiper-pagination"></div>
                    </div>
                </div>
            </section>

            <section class="faq section" id="faq">
                <h2 class="section__title">
                    よくあるご質問 <br>
                    <span>Frequently Asked Questions</span>
                </h2>

                <div class="faq__container container grid">
                    <!-- Q1: チート性 -->
                    <div class="faq__item">
                        <header class="faq__header">
                            <i class="ri-add-line faq__icon" aria-hidden="true"></i>
                            <h3 class="faq__title">本アプリは「チート（違反行為）」に当たるのですか？</h3>
                        </header>
                        <div class="faq__content">
                            <p class="faq__description">
                                これは、原則として「いいえ」と解されます。<br><br>

                                本アプリは、他社のサービスや競技システムに対する不正介入や改変を行う性質のものではなく、
                                日本法上の「不正アクセス禁止法」や著作権法における「技術的保護手段の回避」に該当するような設計・実装は含まれていません。<br><br>

                                本アプリは<strong>独立した Windows 向け実行ファイル</strong>であり、外部サービスのプロセス・メモリ・通信を改変しません。
                                したがって、アクセス制御機能を迂回したり暗号化通信を解読する行為にあたらず、不正アクセス禁止法（平成11年法律第128号）に定義される「不正アクセス行為」には該当しません。
                                また、著作権法で禁止される技術的保護手段の回避（コピーガード解除等）とも無関係です。<br><br>

                                ただし、オンライン競技やランキングサービスの利用規約においては「外部プログラムを用いた解答」を禁止している場合があります。
                                この場合に本アプリを利用すれば、法的な意味での「違法」ではなくとも、契約上の「規約違反」とみなされる可能性があります。
                                したがって、本アプリの利用は<strong>研究・教育・オフライン環境</strong>に限定することを強く推奨します。<br><br>

                                内部的な処理はすべて自プロセス内で完結しており、推論則 $\mathcal{R}$ の反復適用、制約伝播、分枝限定探索などの計算操作のみを行います。
                                数独は一般化すると NP 完全であることが知られており（Yato &amp; Seta, 2003）、さらに「一意解性の判定」$\mathsf{UNQ}(P)$ は DP 完全に属します。
                                本ソフトウェアは盤面を有限領域制約充足問題 $P = (V,\{D_v\}_{v \in V},C)$ として厳密にモデル化し、充足写像 $f: V \to D_v$ を探索・検証することで、解の存在や一意性を純粋に数理的に導出します。
                                すなわち、これは「外部システムを欺くチート」ではなく「研究対象を形式的に解く行為」そのものです。
                            </p>
                        </div>
                    </div>

                    <!-- Q2: 無償性 -->
                    <div class="faq__item">
                        <header class="faq__header">
                            <i class="ri-add-line faq__icon" aria-hidden="true"></i>
                            <h3 class="faq__title">利用は無償なのですか？</h3>
                        </header>
                        <div class="faq__content">
                            <p class="faq__description">
                                はい。<br><br>

                                現行バージョンは利用者に無償で提供され、料金は発生しません。
                                この無償性は一過性の便宜ではなく、<strong>オープンソース・ソフトウェア（OSS）の文化</strong>に根ざした理念的選択です。
                                すなわち、著作権を保持したままライセンス（例：Apache License 2.0）の下で利用・複製・改変・再配布を許諾することにより、学術的共同体における透明性と再現可能性を最大限に担保しています。<br><br>

                                研究においては、アルゴリズムの検証可能性と反証可能性が不可欠です。
                                そのためには誰もが同一条件下で計算を再現できる環境が必要であり、無償配布はその前提を制度的に支えます。<br><br>

                                技術的にも広告やトラッキングを組み込まず、外部通信を行わない設計としています。
                                そのため利用者の計算資源や通信回線が収益化の手段として用いられることはなく、端末内で閉じた純粋な計算・可視化機能にアクセスできます。
                                問題 $P = (V,\{D_v\}_{v \in V},C)$ に対して充足写像 $f: V \to D_v$ を構築する数理的プロセスが、外部コストや課金に左右されることはありません。<br><br>

                                <em>注</em>：将来的に研究支援や高度な拡張機能を有償オプションとして提供する可能性はありますが、解法・可視化・一意性検証といった基礎機能は今後も無償で継続提供する方針です。
                            </p>
                        </div>
                    </div>

                    <!-- Q3: データ収集 -->
                    <div class="faq__item">
                        <header class="faq__header">
                            <i class="ri-add-line faq__icon" aria-hidden="true"></i>
                            <h3 class="faq__title">利用者データが収集されることはあるのですか？</h3>
                        </header>
                        <div class="faq__content">
                            <p class="faq__description">
                                いいえ。<br><br>

                                ソフトウェアは設計段階から「利用者データを収集しない」ことを前提に構築されています。
                                入力された盤面や操作履歴、環境情報が外部に送信されることはなく、通信ソケットの初期化やファイアウォール例外の登録も行われません。
                                生成される成果物はローカル環境にのみ保存され、端末外に出ることはありません。<br><br>

                                このような構造のもとでは、利用に際して個人情報保護法や GDPR に見られる外部送信や国外移転の問題は生じません。
                                さらに、この無通信性は理念上の主張ではなく、<code>netstat</code> やプロセス監視ツールを用いることで利用者自身が検証可能な事実です。<br><br>

                                数理的に見ても、本ソフトウェアの対象は数独盤面を CSP として定式化した問題 $P = (V,\{D_v\}_{v \in V},C)$ であり、その充足写像 $f: V \to D_v$ を構築することに尽きます。
                                この計算過程に利用者の個人情報は一切関与せず、設計原理上も機能要件上もデータ収集は生じ得ません。
                            </p>
                        </div>
                    </div>

                    <!-- Q4: 商用利用・再配布 -->
                    <div class="faq__item">
                        <header class="faq__header">
                            <i class="ri-add-line faq__icon" aria-hidden="true"></i>
                            <h3 class="faq__title">商用利用や再配布は可能なのですか？</h3>
                        </header>
                        <div class="faq__content">
                            <p class="faq__description">
                                はい。ただし、ライセンス条項に従うことが前提となります。<br><br>

                                提供はオープンソース・ソフトウェア（OSS）の理念に基づき、ライセンス（例：Apache License 2.0）の下で行われています。
                                このライセンスは改変や再配布、商用利用を許容していますが、それは「無条件の自由」ではなく、
                                著作権表示やライセンス文書の同梱、改変箇所の明示、商標や名称に関する規律を遵守することを条件とした自由です。<br><br>

                                条件を満たさずに利用すればライセンス違反となり、著作権侵害や不正競争行為として法的責任を問われる可能性があります。
                                逆に条件を適切に守れば、企業活動、教育利用、派生研究の公開といった場面でも正当に活用できます。<br><br>

                                学術的観点から見れば、OSS ライセンスは知識と技術の共有を制度的に支える仕組みです。
                                数理研究においては、他者による再検証や拡張が不可欠であり、ライセンスはその透明性と発展可能性を保証するものとなっています。<br><br>

                                ソフトウェアが解く課題は、数独盤面を CSP として定式化した $P = (V,\{D_v\}_{v \in V},C)$ に対し、充足写像 $f: V \to D_v$ を導出するという純粋な計算作業です。
                                この計算ロジック自体は公開知の一部であり、誰もが検証・改良し、必要に応じて商用に活かすことができます。
                                したがって、商用利用や再配布は可能ですが、必ずライセンスの条件を理解し遵守する必要があります。
                            </p>
                        </div>
                    </div>

                    <!-- Q5: 動作環境 -->
                    <div class="faq__item">
                        <header class="faq__header">
                            <i class="ri-add-line faq__icon" aria-hidden="true"></i>
                            <h3 class="faq__title">動作環境を教えていただけますか？</h3>
                        </header>
                        <div class="faq__content">
                            <p class="faq__description">
                                本ソフトウェアは<strong>Windows 10 / 11（x64）環境</strong>を標準的な対象としています。
                                設計にあたり追加の仮想マシンや専用ランタイムを必要とせず、単独の実行ファイルとして完結する形態を採っています。
                                これは、環境依存性を極力排除し、利用者が容易に導入できるように配慮したものです。<br><br>

                                他方で、ARM アーキテクチャや旧世代の OS（Windows 8.1 以前など）は正式には対象外であり、動作が保証されません。
                                研究ツールとして安定した再現性を確保するため、プラットフォームを限定することは合理的な要請でもあります。
                                数独を CSP として定式化した $P = (V,\{D_v\}_{v \in V},C)$ を処理するための計算資源は比較的軽量ですが、
                                解の探索や一意性検証では分枝限定法が指数的な計算負荷をもたらす場合があります。
                                そのため、ある程度の CPU 性能とメモリ容量を備えた環境が望ましいといえます。<br><br>

                                以上の理由から、公式に推奨される動作環境は Windows 10 / 11（x64）であり、それ以外の環境での利用は検証されていないため推奨されません。
                            </p>
                        </div>
                    </div>

                    <!-- Q6: 安全性 -->
                    <div class="faq__item">
                        <header class="faq__header">
                            <i class="ri-add-line faq__icon" aria-hidden="true"></i>
                            <h3 class="faq__title">安全性は担保されているのですか？</h3>
                        </header>
                        <div class="faq__content">
                            <p class="faq__description">
                                はい。<br><br>

                                配布物の安全性は、設計原理と検証可能な手続きの双方から担保されています。
                                まず、外部通信を伴わない構造であるため、利用者データが外部に流出する経路は存在しません。
                                次に、配布されるバイナリには <code>SHA-256</code> ハッシュ値が公開されており、
                                利用者はダウンロード後にこの値を照合することで、改ざんや途中攻撃の有無を自ら確認することができます。
                                暗号学的ハッシュ関数の衝突困難性に依拠したこの方法は、実務的に強固な検証手段といえます。<br><br>

                                もっとも、EV 証明書や OV 証明書によるコード署名は行っていないため、初回実行時に Windows SmartScreen が警告を発する場合があります。
                                しかしこの警告は「マルウェアである」ことを意味するのではなく、「新規に配布された未署名の実行ファイル」であることを通知するに過ぎません。
                                署名を導入する予定はなく、この点については利用者の理解が求められます。<br><br>

                                また、安全性の確認は利用者自身の手で補強することが可能です。正規の配布ページから入手し、公開されたハッシュ値を照合することが第一です。
                                加えて、必要に応じて <code>Windows Defender</code> や仮想環境での隔離実行を行い、挙動を観察することもできます。
                                さらに、ネットワークモニタを用いることで、本ソフトウェアが外部サーバーに接続しないことを客観的に検証できます。<br><br>

                                以上のように、外部依存を排除した設計と暗号学的検証手段、そして利用者自身による検証可能性の三点によって、安全性は担保されています。
                            </p>
                        </div>
                    </div>

                    <!-- Q7: アルゴリズムの正当性と一意解の保証 -->
                    <div class="faq__item">
                        <header class="faq__header">
                            <i class="ri-add-line faq__icon" aria-hidden="true"></i>
                            <h3 class="faq__title">解法アルゴリズムの正当性と解の一意解は保証されているのですか？</h3>
                        </header>
                        <div class="faq__content">
                            <p class="faq__description">
                                はい。<br><br>

                                本ソフトウェアに実装されている解法アルゴリズムの正当性と一意解の保証は、数学的な理論的基盤と実際の計算手続きの双方によって支えられています。
                                まず推論部分については、<strong>Knaster–Tarski の不動点定理</strong>を根拠とし、有限集合上の単調写像 $F$ を Kleene 反復で適用することで、必ず最小不動点 $\mathrm{lfp}(F)$ に到達することが保証されます。
                                推論則 $\mathcal{R}$ は制約集合 $C$ の論理的帰結を忠実に反映するよう設計されており、得られる閉包は健全かつ完全です。<br><br>

                                一方、探索部分は<strong>分枝限定法</strong>によって担保されます。
                                CSP $P = (V,\{D_v\}_{v \in V},C)$ の解候補を樹状に展開し、矛盾が生じた枝を剪定することで、残された経路はすべて制約を充足するものに限られます。
                                この方法によって導かれる写像 $$f: V \to \prod_{v \in V} D_v$$ は、定義上必ず問題の制約を満たす解となります。<br><br>

                                さらに、一意解の保証は「数学的定義としての原理」と「アルゴリズムによる実際の検証」とを区別して理解する必要があります。
                                理論的には、一意解判定は $|\mathrm{Sol}(P)|=1$ であるかを問う問題であり、これは計算量理論において DP 完全に分類されます。
                                NP と coNP の困難性を併せ持つため、効率的解法は存在しない可能性が高いと考えられます。
                                しかし実装上は、一つの解を構築したのち、二つ目の解の存在を逆証的に確認することで「唯一である」と構成的に証明する手続きが採用されています。
                                この方法は「解の存在証明」と「非多重性の検証」を組み合わせた実践的アプローチであり、有限盤面に対しては実用的に十分機能します。<br><br>

                                総じて、推論則に基づく閉包計算、不動点理論の保証、分枝限定探索の組合せ的厳密性、そして一意性判定の構成的手続きが相補的に作用することにより、アルゴリズム全体の健全性と正当性が確立されています。
                                これにより、得られる解が「数学的に導出された正しいもの」であることが担保されるのです。<br><br>

                                <em>注</em>：ここまで高尚な理論を並べ立てましたが、筆者自身は慶應生とはいえ文系であり、証明論的な厳密性のすべてを保証できる立場ではありません。
                                それでも、形式的な整合性に基づいて実装されている点は確かであり、少なくとも「理論と実装が大きく乖離しているわけではない」という安心感はお持ちいただけるのではないでしょうか。（笑）<br><br>

                                <em>補足</em>：より詳細な理論的背景や証明の整合性については、別途公開している「研究路線（アプローチ）」ドキュメントをご参照ください。
                            </p>
                        </div>
                    </div>
                </div>
            </section>

            <section class="approach section" id="approach">
                <h2 class="section__title">
                    研究路線（アプローチ）<br>
                    <span>Formal Approach & Theory</span>
                </h2>

                <div class="approach__frame" aria-label="研究路線本文の閲覧領域">
                    <article class="approach__scroll" id="approach-doc" tabindex="0">

                        <h2 id="abstract">要旨</h2>
                        <p class="muted">
                            本稿は、数独解読を有限領域制約充足問題 (CSP) として位置づけ、その理論的基盤から実装設計・可視化アプリケーションに至るまでを統合的に論じる。
                            全体は第1節から第12節で構成され、数理的定式化、推論規則、探索手法、実装効率、難易度計量、問題生成、GUI、Core API、DLXアルゴリズム、複雑性分析、テスト規律、そして総括に至る流れを示す。
                            まず (第1節) において CSP としての定義と一意解性の条件を導入し、(第2節) では候補削減や部分盤面推論を縮約作用素の不動点として形式化する。
                            推論のみでは不十分な場合に対しては (第3節) 限定的探索を導入し、MRV や Degree ヒューリスティクスによる効率化を論じる。
                            実装面では (第4節) ビットマスクによる高速な候補管理を示し、(第5節) 各規則や探索に原価を割り当てることで難易度を定量化する。
                            問題生成については (第6節) 完全盤からの削除による逆問題設定を提示し、(第9節) で DLX アルゴリズムを用いた厳密な一意性判定を扱う。
                            さらに (第7節) GUI による可視化、(第8節) Core API によるモジュール化を述べる。最後に (第10節) 探索木の複雑性分析と剪定戦略、(第11節) テスト規律を整理し、(第12節) として数独解読研究の展望を示す。
                            以上により、本稿は「数独」というパズルを超えて、制約充足問題における推論・探索・可視化を統合的に設計する一例を与える。
                        </p>

                        <nav class="approach__toc-inline" aria-label="目次">
                            <h3 class="approach__toc-title">目次</h3>
                            <ul class="approach__toc-list">
                                <li><a href="#1-csp-formulation">1. 数独の数理的定式化：制約充足問題としての構造と一意解性</a></li>
                                <li><a href="#2-inference-rules">2. 推論規則の設計</a></li>
                                <li><a href="#3-limited-search">3. 限定的探索</a></li>
                                <li><a href="#4-data-structures">4. データ構造と演算効率</a></li>
                                <li><a href="#5-difficulty-metrics">5. 難易度の計量学</a></li>
                                <li><a href="#6-puzzle-generation">6. 問題生成と一意性保証</a></li>
                                <li><a href="#7-gui-visualization">7. GUI と可視化</a></li>
                                <li><a href="#8-core-api">8. Core API の設計</a></li>
                                <li><a href="#9-dlx-algorithm">9. 生成アルゴリズム（DLX）</a></li>
                                <li><a href="#10-complexity-optimization">10. 複雑性の分析と最適化</a></li>
                                <li><a href="#11-testing">11. テスト規律</a></li>
                                <li><a href="#12-conclusion">12. まとめ</a></li>
                                <li><a href="#references">参考文献</a></li>
                            </ul>
                        </nav>

                        <h2 id="1-csp-formulation">1. 数独の数理的定式化：<ruby>制約充足問題<rt>せいやくじゅうそくもんだい</rt></ruby>としての構造と<ruby>一意解性<rt>いちいかいせい</rt></ruby></h2>
                        <div class="para">
                            <p>　数独は単純なパズルとして大衆的に親しまれているが、数学的に捉えるならば有限領域制約充足問題（Constraint Satisfaction Problem, CSP）の代表例として位置づけられる。この視点に立つと、数独は単なる娯楽にとどまらず、計算複雑性理論、抽象代数学、情報理論、さらには実用的なアルゴリズム設計に至るまで多岐にわたる学術的意義を持つことが明らかになる。有限 CSP は厳密には三つ組 $(V,\{D_v\}_{v\in V},C)$ によって与えられる。</p>
                            <p><em>記法</em>：以後、<span class="math">$[9] := \{1,2,\dots,9\}$</span> と略記する。</p>
                            <p>ここで $V$ は有限の変数集合であり、各 $v\in V$ には有限集合 $D_v$ が値域として割り当てられる。$C$ は制約の族であり、各制約 $c\in C$ はスコープ $\operatorname{scope}(c)=(v_1,\dots,v_k)$ と、その関係</p>
                            <figure class="eq">$$R_c \subseteq \prod_{i=1}^k D_{v_i}$$</figure>
                            <p>との組で記述される。解とは写像 $\sigma:V\to \bigsqcup_{v} D_v$ であって、任意の $c\in C$ に対して $(\sigma(v_1),\dots,\sigma(v_k))\in R_c$ を満たすものである。一般形では全変数に共通の値域 $D$ を採用するが、数独の場合も $D=\{1,\dots,9\}$ として統一できる。数独の具体化においては、変数集合を $V=\{x_{r,c}\mid r,c\in\{1,\dots,9\}\}$ と定める。制約族は行・列・各 $3\times 3$ ブロックごとに all-different 制約を課すことで表される。すなわち $\mathrm{AllDiff}(v_1,\dots,v_9)=\{(d_1,\dots,d_9)\in D^9 \mid \forall i\neq j,\ d_i\neq d_j\}$ を定義し、これを 27 系（9 行・9 列・9 ブロック）に適用する。与え値は単項制約 $x_{r,c}=d$ として追加され、全体の問題は $P=(V,D,C\cup G)$ と表される。充足可能性は</p>
                            <figure class="eq">$$\mathsf{SAT}(P):=\exists \sigma:V\to D\ \forall c\in C\cup G,\ \sigma\models c$$</figure>
                            <p>により定義される。ここで $\sigma \models c$ とは、$c$ のスコープ上への $\sigma$ の制限が関係 $R_c$ に属することを意味する。</p>
                            <br>
                            <p>　一意性の判定 $\mathsf{UNQ}(P)$ は、制約充足問題 $P$ に対して「ただ一つの解が存在するか否か」を問う判定問題である。形式的には $\mathsf{UNQ}(P) := (\exists \sigma : \sigma \models P)\ \wedge\ \neg\bigl(\exists \sigma_1 \neq \sigma_2 : \sigma_1,\sigma_2 \models P\bigr)$ と定義される。この定義が示すように、一意性は「少なくとも一つの解が存在する」という充足可能性と、「二つ以上の異なる解が存在しない」という排他性の二側面を同時に包含している。前者の「充足可能性」判定 $\exists\sigma:\sigma\models P$ は、任意の解 $\sigma$ を証拠として提示すれば多項式時間で検証できるため NP に属する。また後者に関しても、二つの異なる解 $\sigma_1,\sigma_2$ が与えられれば、それぞれが $P$ の解であることを確認するのは多項式時間で可能である。したがって「相異なる二解の存在」言語も NP に属し、その否定は coNP に帰属する。以上により $\mathsf{UNQ}(P)$ は NP 言語と coNP 言語の交わりとして表現できる。すなわち</p>
                            <figure class="eq">$$\mathsf{UNQ}(P) \in \mathrm{DP}, \\ \mathrm{DP}=\{\,L_1\cap L_2\mid L_1\in\mathrm{NP},\;L_2\in\mathrm{coNP}\,\}$$</figure>
                            <p>である。DP は Papadimitriou によって導入された複雑性クラスであり、NP∩coNP と一致するわけではなく、それを真に含む交わり型のクラスである点に注意を要する。一般化された数独問題については DP 完全性が知られているが（例：<a href="#ref-yato-seta-2003">Yato–Seta, 2003</a>）、ここでは完全性の議論には立ち入らず、帰属に関する説明にとどめる。</p>
                            <br>
                            <p>　ここで強調すべきは、$\mathsf{UNQ}(P)$ の DP 帰属は 言語としての帰属 であり、特定のアルゴリズムや実装戦略に依存しないという点である。すなわち、探索の順序選択、ヒューリスティクスの設計、候補削減規則の適用順序などの実務的側面は、問題の複雑性クラスとしての本質的地位には影響を与えない。帰属の主張は、あくまでチューリング機械上での言語認識の観点から成立する理論的命題であり、個別のアルゴリズム設計や実行時間の漸近的挙動と混同されるべきではない。この言語的帰属に直ちに付随するのは、候補集合の数理構造の厳密な分析である。すなわち、各セル $(r,c)$ に割り当てられる候補集合 $S_{r,c}\subseteq D$ を座標ごとに積み重ねた空間 $\mathcal L=\mathcal P(D)^V$ を考える。この空間においては、通常の包含順序ではなく、その反対である反包含順序を導入するのが自然である。</p>
                            <br>
                            <p>　すなわち $X \sqsubseteq Y \stackrel{\text{def}}{\iff} X \supseteq Y$ と定める。この反包含順序の下では、候補削減作用素は膨張的（inflationary）写像として振る舞う。ここで「膨張的」とは、順序に従えば常に $X \sqsubseteq F(X)$ が成り立つことを意味し、直観的には「候補集合を縮小させる操作」が順序関係上は拡張的に見えることを表す。実際、all-different 制約や与え値から誘導される候補削減作用素 $F:\mathcal{L}\to\mathcal{L}$ は、任意の $X,Y\in\mathcal{L}$ に対して
                            <figure class="eq">$$X \sqsubseteq Y \;\Rightarrow\; F(X)\sqsubseteq F(Y), \\ X \sqsubseteq F(X)$$</figure>
                            <p>を満たす単調かつ膨張的な作用素として定義できる。Knaster–Tarski の不動点定理（例：<a href="#ref-tarski-1955">Tarski, 1955</a>）によれば、完備束上の単調写像は必ず最小不動点 $\operatorname{lfp}(F)$ と最大不動点 $\operatorname{gfp}(F)$ を持つ。数独の候補削減においては前者が意味を持つ。さらに $(\mathcal L, \sqsubseteq)$ は有限格子であるため、降鎖条件（descending chain condition）が自動的に成立し、Kleene 反復（例：<a href="#ref-kleene-1952">Kleene, 1952</a>）</p>
                            <figure class="eq">$$X_0=\bot,\qquad X_{i+1}=F(X_i)$$</figure>
                            <p>を下限元 $\bot$（すなわち「各セルの候補が最大集合 $D$」）から開始すれば、ある有限の $N$ に対して</p>
                            <figure class="eq">$$X_N = X_{N+1} = \operatorname{lfp}(F)$$</figure>
                            <p>が成立し、有限ステップで必ず最小不動点に到達する。すなわち、Knaster–Tarski が存在を保証する不動点を、Kleene 反復は実際に構成的に与えることになる。この収束性は同期的な一斉更新に限らず、非同期反復（chaotic iteration）においても保持される。すなわち、写像族が単調であり格子が有限である限り、局所的な更新をワークリスト方式で行っても、最終的には必ず $\operatorname{lfp}(F)$ に到達する。</p>
                            <br>
                            <p>　この束論的保証を数独解法に適用すれば、更新の生じたセルの近傍三系（同じ行・列・ブロック）をワークリストに再投入することで効率的な昇鎖を実現できる。数独の制約グラフでは各セルが約 20 の近傍を持ち、全体の辺数は $e \approx 810$ 程度にすぎない。また候補値域 $d=9$ は定数であるため、更新操作の計算コストは理論的には「更新回数に比例する定数倍」と評価できる。従って候補削減の収束過程は、計算複雑性理論上の DP 帰属と矛盾することなく、束論に基づく安定性保証を伴い効率的に実装可能であることが明らかになる。</p>
                            <br>
                            <p>　弧整合（AC-3, AC-2001）や一般化整合（GAC）は、関係の射影・前像に基づく具体的な $F$ の実現であり、その健全性は「削除される候補は現行の制約下で支持の無い値のみ」という性質により保証され、完全性は「$\operatorname{lfp}(F)$ 到達後は、局所的な意味でこれ以上削減できない」こととして特徴づけられる。計算量の見積もりにおいて、AC-3 はエッジ数 $e$ 、領域サイズ $d=|D|$ に対し $O(ed^3)$、改良型の AC-2001 は $O(ed^2)$ の振る舞いを示すと解析されるが、数独では $d=9$ が定数であるため、実務上はセル数 $81$ と制約の疎密構造が支配的となる。さらに all-different に対してはマッチング理論に基づく強整合化（Regin のアルゴリズム）により、集合被覆の観点から候補削除が可能であるが、これも作用素 $F$ の特殊化として理解できる。</p>
                            <br>
                            <p>　候補格子の縮約を定量化するために情報理論的尺度を導入する。独立一様近似の下で各セルに対し $H(x_{r,c})=\log_2 |S_{r,c}|$ を定義し、盤面の不確実性を $H(P)=\sum_{r,c} \log |S_{r,c}|$ と置く。これは真の結合エントロピーに対する上界的ヒューリスティクであり、相関を無視するという近似を内在するものの、縮約作用素の単調性から $\Delta H\le 0$ が常に成り立つ。すなわち、候補削減 $F$ は各セルの候補数 $|S_{r,c}|$ を減少させる方向にしか作用しないため、全体の和 $H(P)$ も必ず単調非増加する。</p>
                            <br>
                            <p>　探索においては、候補最小原理（MRV）$(r^*,c^*)\in\operatorname{argmin}_{(r,c)} |S_{r,c}|$ を基本規準とし、同点を weighted degree（各制約の失敗履歴に基づく重み $w(c)$ を用いて $\sum_{c\ni (r,c)} w(c)$ を最大化する）や、仮置き後の局所伝播により得られる期待 $-\Delta H$ を優先することで整序する。ここで $-\Delta H$ をより素直に確率的利得として扱うなら、各セル候補に一様事前
                            <figure class="eq">$$p(d) = \frac{1}{\lvert S_{r,c}\rvert}$$</figure>
                            <p>を置き、仮置き後の候補サイズから事後 $q(d)$ を近似して</p>
                            <figure class="eq">$$\mathrm{IG}(d) = \log |S_{r,c}| - \sum_{(r',c')} \log |S'_{r',c'}|$$</figure>
                            <p>を比較すればよい。分布としての挙動を強調するなら、微小平滑 $\epsilon>0$ による正則化を加えた</p>
                            <figure class="eq">$$\mathrm{KL}(p\parallel q)=\sum_{d\in D} p(d)\log\frac{p(d)}{q(d)+\epsilon}$$</figure>
                            <p>を用いて推論規則の証拠強度を測ることも可能である。もっとも、これらは厳密な意味での統計モデル化ではなく、縮約量を秩序化するための理論的に一貫した近似的序関係を与えるものとして解すべきである。</p>
                            <br>
                            <p>　計算複雑性の観点では、一般化された $n^2\times n^2$ 数独の充足可能性が NP 完全であることは標準的な結果であり、CNF SAT もしくはグラフ彩色からの多項式時間帰着によって示される。CNF への符号化では、命題変数 $X_{r,c,d}$ を「セル $(r,c)$ に値 $d$ を置く」ことに対応させると、変数は $9\cdot 9\cdot 9=729$ 個となる。各セルちょうど一つの値という制約は</p>
                            <figure class="eq">$$\displaystyle \bigvee_{d=1}^{9} X_{r,c,d} \;\land\; \bigwedge_{\substack{d,d'\in[9]\\ d\neq d'}}\!\bigl(\neg X_{r,c,d}\vee \neg X_{r,c,d'}\bigr)$$</figure>
                            <p>により与えられ、行・列・ブロックごとの all-different は値ごとに</p>
                            <figure class="eq">$$ \displaystyle \begin{aligned} &\bigwedge_{r\in[9]}\ \bigwedge_{\substack{c,c'\in[9]\\ c\neq c'}}\!\bigl(\neg X_{r,c,d}\vee \neg X_{r,c',d}\bigr),\\ &\bigwedge_{c\in[9]}\ \bigwedge_{\substack{r,r'\in[9]\\ r\neq r'}}\!\bigl(\neg X_{r,c,d}\vee \neg X_{r',c,d}\bigr),\\ &\bigwedge_{\,\mathcal B}\ \bigwedge_{\substack{(r,c),(r',c')\in \mathcal B\\ (r,c)\neq (r',c')}}\!\bigl(\neg X_{r,c,d}\vee \neg X_{r',c',d}\bigr). \end{aligned}$$</figure>
                            <p>で与えられる。節数の増加は定数倍を含めても $O(9^3)$ の範囲に収まり、標準盤面でも数万節程度に過ぎない。たとえば各セルについての「少なくとも一つ（ALO）」は 81 節、続く「一つに限定（AMO）」は $81\times 36 = 2,916$ 節を生み出す。さらに行・列・ブロックごとに値 $d$ を重複なく割り当てる制約を加えると、全体でおよそ 1.2 万節規模に達する。</p>
                            <br>
                            <p>　CNF 符号化の正当性は、整合性（解があれば CNF を充足）と完全性（CNF のモデルから数独の解が復元可能）によって二方向で確認される。Exact Cover への還元は別の等価定式化であり、行列 $A\in\{0,1\}^{729\times 324}$ を、行が候補 $(r,c,d)$、列が 4 種類の制約</p>
                            <figure class="eq">$$\text{cell}_{r,c},\quad \text{row}_{r,d},\quad \text{col}_{c,d},\quad \text{box}_{\beta,d}$$</figure>
                            <p>で表され、ブロック番号 $b$ はセル座標 $(r,c)$ から $\beta=3\lfloor(r-1)/3\rfloor+\lfloor(c-1)/3\rfloor+1$ によって一意に定まる。この規則に従って行列を構成し、該当する制約列に 1 を立てると、問題は「各列をちょうど一度ずつ被覆する行集合」を求める Exact Cover として定式化される。Algorithm X はこの被覆集合を探索する手続きであり、Dancing Links（DLX）はその効率的な連結リスト実装である。正当性は、選ばれた行集合が正確に一つの値割当と 4 種の制約充足を同時に与えることから直ちに従う。さらに列選択における「最小 1 の列」を優先するヒューリスティクは探索木の分岐係数を平均的に著しく低減し、この点で候補格子側の MRV（Minimum Remaining Values）ヒューリスティクと概念的に対応する。すなわち MRV が「選択肢の稀少なセル」を選ぶのに対し、DLX の列最小選択は「支持の稀少な制約列」を選ぶのであり、両者はいずれも希薄性という同一の構造特性を異なる表現系で測っているに他ならない。</p>
                            <br>
                            <p>　一意性検証に関しては、$\mathsf{UNQ}(P)$ の定義が示す通り存在と非存在の複合であるため、実装上は「一解発見後、別解を一つ見つけ次第停止する」戦略が自然である。これは誤陰性を生まない（別解が存在すれば必ず見つけた時点で非一意と結論できる）が、誤陽性を避けるには「発見されなかった」ことの側にも証明的重みが必要であり、探索戦略は有限であること、枝刈りは健全であることが条件となる。DLX の場合、列カバーの全探索は有限であり、特定の枝刈り（例えば一意性検査に不要な対称性の打ち切り）を導入しない限り、探索空間の完全走査により非存在が保証される。候補格子側の探索では、局所推論の健全性（削除は常に安全）とバックトラックの完全性（全割当への網羅）により、同様に非存在の主張が裏付けられる。</p>
                            <br>
                            <p>　代数学的視点は、完成盤の計数や生成過程における重複排除において決定的な役割を果たす。数独盤面に保存される対称性としては、数字置換群 $S_9$、行や列のバンド・スタック単位の置換、各バンド内の行置換および各スタック内の列置換、さらに正方形の回転・反転を表す二面体群 $D_4$ が挙げられる。これらを総合した群 $G$ が盤面集合 $\Omega$ に作用するとき、群作用は軌道分解</p>
                            <figure class="eq">$$\Omega = \bigsqcup_i G \cdot \omega_i$$</figure>
                            <p>を与える。このとき各軌道の大きさは安定化群 $G_\omega$ を用いて</p>
                            <figure class="eq">$$|G \cdot \omega| = \frac{|G|}{|G_\omega|}$$</figure>
                            <p>と表され、計数と同型排除の双方に利用できる。さらに、群作用では Burnside の補題</p>
                            <figure class="eq">$$|\Omega/G| = \frac{1}{|G|} \sum_{g \in G} |\operatorname{Fix}(g)|$$</figure>
                            <p>により、群作用の下での同型類の数が「固定される盤面の個数」の平均として評価できる。実務的には、生成段階で代表元規約（例えば辞書式最小の行列形）を課すことで、探索木における同型分枝を未然に抑圧することが有効である。</p>
                            <br>
                            <p>　難易度の定量化に関しては、単なる手数や分岐回数を超えて、縮約過程と探索過程の双方を統合する汎関数として定義するのが自然である。情報理論的観点からは、時間を離散化して $t=0,1,\dots,T-1$ としたとき、
                            <figure class="eq">$$\mathcal D(P) = \sum_{t=0}^{T-1} \bigl(-\Delta H_t\bigr) + \lambda \sum_{b \in \mathcal T}\bigl(1+\mu\,\mathrm{depth}(b)\bigr)$$</figure>
                            <p>と表せる。ここで $-\Delta H_t$ は時刻 $t$ における情報量減少（候補集合の対数サイズの減少）を表し、$B$ は探索分岐の集合、$\mathrm{depth}(b)$ は分岐 $b$ の深さである。定数 $\lambda,\mu>0$ は単位系を整えるための重みであり、推論が停滞する局面では探索コストが支配的に、推論が強力に働く局面では $-\Delta H_t$ が支配的となる。</p>
                            <br>
                            <p>　経験的観察によれば、$-\Delta H_t$ の寄与はしばしばサブモジュラ関数に類似した漸減性を示す。すなわち、手筋の追加適用による限界効用は逓減する傾向があり、この性質はサブモジュラ最適化における貪欲法の近似保証とアナロジーを持つ。従って、候補削減規則を貪欲的に適用する戦略が実際に高品質の近似解法を与えるという経験則には、理論的根拠が付与される。</p>
                            <br>
                            <p>　Python による計算的実現は、上述の理論をそのまま具体化する。候補集合を 9 ビット整数 $C_{r,c}\in\{0,\dots,2^9-1\}$ で表現し、ビット番号は $d\in\{1,\dots,9\}$ を 1-based として $\mathrm{mask}(d)=1\ll (d-1)$ を採る。行・列・ブロックの使用済み集合 $U^\mathrm{row}_r,U^\mathrm{col}_c,U^\mathrm{box}_b$ をビット和で維持し、更新則</p>
                            <figure class="eq">$$C_{r,c}\leftarrow C_{r,c}\ \&\ \neg\Bigl(U^\mathrm{row}_r\ \vert\ U^\mathrm{col}_c\ \vert\ U^\mathrm{box}_b\Bigr)$$</figure>
                            <p>により禁止値を排除する。候補数は $\mathrm{popcount}(C_{r,c})$ により定数時間で得られる。Kleene 反復は、固定長のキューで「変化したセルの近傍三系」を再処理することで実現でき、停止は有限束上の降鎖条件から自動的に保証される。探索では MRV により $\min \mathrm{popcount}$ のセルを選び、同数の場合には仮置き → 局所伝播 → $-\Delta H$ ないし dom/wdeg の増加が最大のものを優先する。ここで dom/wdeg は、失敗した制約に重みを加算し、以後その制約に関与する変数が優先されるようにする経験的にも強力な規準である。DLX への切替は、候補格子が不動点に達し、かつ未確定セルが残る局面で行うのが自然で、候補稀少性の極端な列（値・行・列・ブロックのいずれか）から探索することで分岐係数を抑える。ユニット伝播や二項節学習に相当する「ノーグッド学習」は、候補格子側では禁則パターンとして、DLX 側では部分的列被覆の不能集合として蓄積でき、いずれも探索の重複を抑止する。</p>
                            <br>
                            <p>　生成問題においては、完全盤 $\sigma$ を乱択により獲得し、与え値集合 $G\subseteq V$ を初期化した後、$G$ から要素を一つずつ候補削除して一意性が保持される場合に限り削除を確定する。ここでの一意性検証は、DLX により一解を見つけた後、二解目の探索を行い、見つかればただちに「非一意」と結論し、見つからなければ全探索の完走によって「一意」を主張するという、理論的にも実装的にも節度ある手順で足りる。難易度を制御した問題生成を行うには、削除の各ステップで Kleene 反復がもたらす情報圧縮 $-\Delta H$ の積算や、のちの探索で消費される分岐コストの予測値を合成したメタロス $\Phi(G)$ を設計し、焼きなましや確率的勾配法により所望の $\Phi$ に近づくよう与え値を選別する。群作用の利用により、与え値集合 $G$ の同型を事前に同値類へ商取りすることで、冗長な候補を塊ごと棄却でき、探索空間は指数的に圧縮される。最後に、数独が「単純さ」と「可圧縮性」の緊張を内蔵する数学的対象であることを強調する。完成盤の総数は天文学的であり探索空間 $9^{81}$ は桁外れであるにもかかわらず、候補格子上の単調縮約と、情報利得を最大化する探索規準の組合せは、与え値の少ない局面からでも短い計算で大きなエントロピーを消去する。ここで働いているのは、完備束上の不動点理論、群作用と同値類の商、Exact Cover による厳密離散最適化、そして情報理論的尺度による序付けであり、これらが一体となって「手筋」と呼ばれる人間のヒューリスティクを理論の言葉で再解釈する。解が一意であるとは、Exact Cover の観点では列選択の軌道がただ一つの被覆に収束すること、情報理論の観点では $H(P)\to 0$ が唯一の経路で達成されること、格子論の観点では $\operatorname{lfp}(F)$ の近傍が単一の極小要素に収束することに等価である。かくして数独は、遊戯と学理の二重性を統合し、有限数学の深層を可視化する作動的理論模型として、研究書の対象に相応しい厳格さと豊穣さを兼ね備えている。</p>
                        </div>

                        <h2 id="2-inference-rules">2. <ruby>推論規則<rt>すいろんきそく</rt></ruby>の設計</h2>
                        <div class="para">
                            数独を <ruby>制約充足問題<rt>せいやくじゅうそくもんだい</rt></ruby> (CSP) として定式化した場合、解読過程の核心は候補集合の段階的削減にある。候補集合全体は

                            $$\Sigma = \prod_{r,c} \mathcal{P}(\{1,\dots,9\})$$

                            と表され、 $\sigma \in \Sigma$ は「全セルにおける候補集合の配置」を意味する。この $\Sigma$ は包含関係に基づく順序構造を持ち、<ruby>完備束<rt>かんびそく</rt></ruby> (complete lattice) をなす。最大元は「全てのセルが $\{1,\dots,9\}$ を候補として保持する状態」、最小元は「全てのセルが確定値を持つ解状態」である。候補削減の過程を束上の写像として形式化することで、推論規則の性質を一般的な代数的枠組みの中に位置づけることができる。推論規則とは $\gamma : \Sigma \to \Sigma$ で表される写像であり、制約に基づいて候補集合を縮小する作用を持つ。この種の作用素は形式概念分析やデータベース理論における <ruby>closure operator<rt>クロージャ作用素</rt></ruby> と同型であり、つねに以下の二性質を満たす。第一に<ruby>単調性<rt>たんちょうせい</rt></ruby> (monotonicity)： $A \subseteq B \implies \gamma(A) \subseteq \gamma(B)$。これは情報が増えれば推論による候補削減もそれに従うことを意味する。第二に<ruby>冪等性<rt>べきとうせい</rt></ruby> (idempotency)： $\gamma(\gamma(\sigma)) = \gamma(\sigma)$。すなわち同一の規則を繰り返し適用しても新しい情報は生じず、有限回の適用で安定化する。これら二つの性質に加え、通常の推論規則は <ruby>縮小性<rt>しゅくしょうせい</rt></ruby> (contractiveness) をも満たす。すなわち $\gamma(\sigma) \subseteq \sigma$ が常に成立し、候補が増えることはない。複数の規則 $\gamma_1,\dots,\gamma_k$ を合成した写像 $\Gamma = \gamma_1 \circ \gamma_2 \circ \cdots \gamma_k$ もまた<ruby>縮約作用素<rt>しゅくやくさようそ</rt></ruby>である。このとき<ruby>反復過程<rt>はんぷくかてい</rt></ruby>

                            $$\sigma_{t+1} = \Gamma(\sigma_t), \qquad \sigma_0 = \sigma_{\text{init}}$$

                            は必ず<ruby>最小不動点<rt>さいしょうふどうてん</rt></ruby>

                            $$\mathrm{lfp}(\Gamma) = \lim_{t \to \infty} \sigma_t$$

                            に到達する。これは Knaster–Tarski の <ruby>不動点定理<rt>ふどうてんていり</rt></ruby> の <ruby>直接的帰結<rt>ちょくせつてききけつ</rt></ruby>であり、到達点 $\mathrm{lfp}(\Gamma)$ は「論理的に尽きるまで候補削減を施した<ruby>極限状態<rt>きょくげんじょうたい</rt></ruby>」に対応する。このことは、推論過程を単なる<ruby>逐次的操作<rt>ちくじてきそうさ</rt></ruby>ではなく、<ruby>不動点計算<rt>ふどうてんけいさん</rt></ruby>として体系的に理解できることを示す。推論規則の適用が有効であるためには、<ruby>健全性<rt>けんぜんせい</rt></ruby> (soundness) が保証されなければならない。形式的には、任意の<ruby>解写像<rt>かいしゃぞう</rt></ruby> $\sigma^* : V \to \{1,\dots,9\}$ に対して

                            $$\sigma^*(r,c) \in \gamma(\sigma)(r,c) \qquad \forall (r,c)\in V.$$

                            すなわち推論によって削除された候補は、元の CSP におけるいかなる解にも含まれない。健全性は局所的な削除操作が解空間を誤って排除しないことを保証する点で不可欠である。一方で、推論規則群が<ruby>完全性<rt>かんぜんせい</rt></ruby> (completeness) を持つとは限らない。すなわち規則適用をいくら繰り返しても候補が一意に収束せず、<ruby>探索<rt>たんさく</rt></ruby>が<ruby>不可避<rt>ふかひ</rt></ruby>となる場合が存在する。したがって推論規則は論理的帰結の「<ruby>計算可能な近似<rt>けいさんかのうなきんじ</rt>
                            </ruby>」に過ぎないが、それでも SAT ソルバにおける unit propagation と同様に、解探索を劇的に効率化する役割を果たす。具体的規則としては、セルの候補が唯一に絞られた場合に確定する naked single、行・列・ブロック内である数字がただ一つのセルにしか現れない場合に確定する hidden single、ブロックと行・列の包含関係に基づく pointing pair や claiming、候補配置の対称性に依拠する X-Wing や Swordfish、さらに候補を命題変数に写像し含意グラフを構成することで矛盾や強制を検出するチェイン規則などが挙げられる。これらはいずれも<ruby>単調性<rt>たんちょうせい</rt></ruby>・<ruby>冪等性<rt>べきとうせい</rt></ruby>を満たし、健全性を保証するため、適用過程全体は「<ruby>形式的証明列<rt>けいしきてきしょうめいれつ</rt></ruby>」として理解できる。極限状態 $\mathrm{lfp}(\Gamma)$ は推論規則のみで到達できる論理的限界を与える。しかし多くの数独問題では、この不動点に到達してもなお未確定のセルが残る。このとき探索（<ruby>分岐帰納法<rt>ぶんききのうほう</rt></ruby>、バックトラック、あるいは<ruby>分岐限定法<rt>ぶんきげんていほう</rt></ruby>）が不可欠となる。すなわち推論規則は探索の<ruby>補助手段<rt>ほじょしゅだん</rt></ruby>として位置づけられ、候補集合を削減し探索空間を大幅に<ruby>剪定<rt>せんてい</rt></ruby>する役割を担う。形式的には、推論は完全な解空間探索に先立つ <ruby>局所的制約伝播<rt>きょくしょてきせいやくでんぱ</rt></ruby> として理解され、計算論的論理における constraint propagation の<ruby>典型的事例<rt>てんけいてきじれい</rt></ruby>と見なせる。結局のところ、数独における候補削減の形式化は、単なるパズル解法技術にとどまらず、縮約作用素の不動点理論、健全性と完全性の区別、制約伝播と探索の相補関係といった<ruby>計算論的基礎概念<rt>けいさんろんてききそがいねん</rt></ruby>を具体的に検証する場を提供する。ここに数独の推論規則の<ruby>学術的価値<rt>がくじゅつてきかち</rt></ruby>がある。
                        </div>

                        <h2 id="3-limited-search">3. <ruby>限定的探索<rt>げんていてきたんさく</rt></ruby></h2>
                        <div class="para">
                            推論規則による<ruby>縮約<rt>しゅくやく</rt></ruby>を繰り返してもなお盤面が完全に決定しない場合、探索が不可避となる。ここでいう探索とは、あるセルに仮置きを行い、その後の帰結を逐次検証しながら<ruby>分岐<rt>ぶんき</rt></ruby>と<ruby>バックトラック<rt>backtrack</rt></ruby>を行う過程を指す。探索空間の理論的上界は $9^{81} \approx 10^{77}$ 通りに及ぶため、無作為な試行は現実的ではない。したがって探索効率の鍵は「どのセルを分岐点に選ぶか」にある。

                            基本的かつ有効な戦略として Minimum Remaining Value (MRV) ヒューリスティクスが知られている。これは候補数が最小のセルを優先的に選択するものであり、早期に矛盾を露呈させて探索木の枝を<ruby>剪定<rt>せんてい</rt></ruby>できる効果を持つ。形式的には「最も制約の強い変数から試す」という原則に対応し、制約伝播を強力に補完する。実際に MRV を用いない場合の探索木の平均分岐数は 5 前後に達するが、MRV を導入することで 2〜3 程度まで減少することが経験的に報告されている。候補数が等しいセルが複数存在する場合には、セルが属する行・列・ブロックにおける未確定セル数が多いものを選択する Degree ヒューリスティクス を組み合わせることが効果的である。これは「最も他に影響を及ぼす変数」を優先する戦略であり、探索効率をさらに高める。より洗練された基準として、情報理論的な指標であるエントロピーを導入することができる。変数 $v$ に候補集合 $D(v)$ が割り当てられているとし、各候補値 $d \in D(v)$ に確率 $p_d$ が割り当てられるとき、その不確実性は

                            $$H(v) = -\sum_{d \in D(v)} p_d \log p_d$$

                            によって測定される。エントロピー $H(v)$ が小さいセルを分岐点として選択することは、探索によって不確実性を最も削減できる箇所を優先することに対応する。確率 $p_d$ の設定方法としては、単純に一様分布 $p_d = \frac{1}{|D(v)|}$ を仮定する場合のほか、制約伝播の頻度や過去の探索履歴に基づいて統計的に推定する方法も考えられる。このアプローチは<ruby>確率的制約充足問題<rt>かくりつてきせいやくじゅうそくもんだい</rt></ruby>やベイズ的最適化との関連を持ち、数独を超えて汎用的な探索戦略への接続を可能にする。探索過程における失敗は単なる後戻りにとどまらない。ある仮置きの下で矛盾が生じた場合、その矛盾は具体的な候補集合に関する「ノーグッド (nogood)」として記録され、以降の探索で再利用される。これが<ruby>失敗駆動学習<rt>しっぱいくどうがくしゅう</rt></ruby> (failure-driven learning) の基本理念である。形式的には、探索におけるノーグッド集合は $\Sigma$ 上の禁止領域を逐次拡張する過程とみなすことができ、これは SAT ソルバにおける<ruby>節学習<rt>せつがくしゅう</rt></ruby> (clause learning) と構造的に同型である。すなわち、局所的な矛盾情報を全体に伝播させることによって、探索の重複計算を回避しつつ<ruby>健全性<rt>けんぜんせい</rt></ruby>を保持することが可能となる。このように限定的探索は、単なる力任せの試行錯誤ではなく、ヒューリスティクスと学習機構を統合した体系的な推論過程である。推論規則による候補削減と探索ヒューリスティクスによる分岐選択とを組み合わせることで、数独の解読は実用的時間内に遂行可能となり、同時に制約充足問題における一般的探索戦略の理論的研究に対しても重要な示唆を与えるのである。
                        </div>

                        <h2 id="4-data-structures">4. データ構造と<ruby>演算効率<rt>えんざんこうりつ</rt></ruby></h2>
                        <div class="para">
                            数独解読の実装効率を根本的に規定するのは、候補集合および制約状態の表現方法である。推論規則や探索戦略の理論的優劣も、実装上の表現形式によって大きく性能が変化するため、この層の設計は単なる実装技法にとどまらず、アルゴリズム工学的な研究対象として重要である。最も有効な表現形式は ビットマスク表現である。各セル $(r,c)$ の候補集合を 9 ビット整数として符号化し、第 $d$ ビットが 1 であるとき、そのセルが数字 $d$ を候補として許容していると解釈する。例えば候補が $\{1,3,9\}$ の場合、そのビット列は $100000101_2$
                            に対応する。この表現を採用することで、候補削減や候補数の計算は低レベルなビット演算に帰着する。具体的には `AND`, `OR`, `XOR` による集合操作、`popcount` による候補数計算などが定数時間で処理できる。すなわち、制約伝播の核心処理をアルゴリズム的に $O(1)$ に収束させることができる。行・列・ブロックごとの使用済み数字の管理も同様に 9 ビット整数で表現できる。あるセルの候補から行・列・ブロックで既に使用済みの数字を排除する操作は

                            $$C_{r,c} \leftarrow C_{r,c} \setminus \{d \mid d \in \text{row}(r) \cup \text{col}(c) \cup \text{box}(b)\}$$

                            に対応し、ビットマスクの単純な除去演算として一括で実行できる。Python のような高水準言語であっても、整数に対するビット演算は極めて高速であり、C 言語レベルの最適化を行わずとも十分に実用的な性能が得られる。すなわち、言語間の実装差はここではほとんど律速要因とならない。さらに洗練された設計として、盤面更新を 永続データ構造 (persistent data structure) として管理する方式がある。これは関数型プログラミングにおける参照透明性を基盤とする設計思想であり、盤面の各更新を差分として記録する。これにより undo/redo 操作は「差分参照の切り替え」として実現でき、任意の過去状態への遡及や分岐状態の保持を効率的に行える。データ構造的には、盤面を木構造や差分リストとして管理し、共有部分を再利用することでコピーコストを削減することができる。この仕組みは単に実装上の利便性にとどまらない。数独の解読過程はしばしば分岐探索と推論削減の反復からなり、複数の盤面状態を並行的に保持する必要がある。このとき永続データ構造を用いれば、バックトラック探索が参照透過的に実行可能となり、探索木全体を効率的に横断する基盤を提供する。すなわち、探索におけるノード遷移が「状態の破壊的変更」ではなく「差分付き状態の選択」として定式化されることにより、計算過程全体が理論的に明瞭かつ実装的に高効率となる。このように、候補集合のビットマスク表現と盤面の永続的管理は、数独アプリケーションの性能とユーザ体験を決定づける基盤である。演算効率の確立によって推論規則や探索戦略が実用的に機能し、差分管理によって人間にとって自然な操作（undo/redo や段階的解読の提示）が可能になる。データ構造と演算効率の設計は、数独解読システムを単なるパズル解法器から、理論的に整備された実験環境へと昇華させる鍵である。
                        </div>

                        <h2 id="5-difficulty-metrics">5. <ruby>難易度<rt>なんいど</rt></ruby>の<ruby>計量学<rt>けいりょうがく</rt></ruby></h2>
                        <div class="para">
                            数独における「難易度」という概念は、素朴に考えれば与え値の数や初期配置の疎密度といった表層的な指標によって測られそうに見える。しかし実際にはそれは不十分であり、問題を解く際にどのような種類の推論規則を適用しなければならないか、その規則の複雑さや人間にとっての認知的負荷がどの程度か、さらに論理規則の適用だけでは解が得られず探索（仮置きとバックトラック）が必要になるかどうかといった要因が総合的に作用している。したがって難易度は、与え値の少なさではなく、解読過程そのものの複雑性を測る複合的な概念として定義されるべきである。この複雑性を形式化するために、まず各推論規則に固有の「原価」を定義する。たとえば naked single のように候補集合が自明に一つに収束する規則は人間にとって直観的に理解可能であるため低コストが割り当てられる。一方で X-Wing や Swordfish といった行列的パターンの検出は視覚的・認知的負荷が大きく、より高いコストを与えることが妥当である。盤面解読の trace を通じて適用された規則の列を $\{r_t\}$ とするとき、論理的コストは

                            $$\mathrm{Cost}_{\text{logic}} = \sum_t w(r_t)$$

                            と定義される。ただし $w(r_t)$ は規則 $r_t$ に割り当てられた定数である。この値は理論的に定めることもできるが、実際には既存の問題集に対する経験的調整によって較正される。しかし、論理規則だけで問題が解けるとは限らない。推論の閉包に達しても未確定セルが残る場合には探索が導入される。このときの探索は、仮置きと矛盾検出に基づく分岐とバックトラックからなるため、計算機的には指数的複雑性を伴い、人間にとっても「試しに置いてみて矛盾を確認する」という非直感的な操作を強いる。従って探索のコストは論理規則よりも桁違いに大きく評価する必要がある。分岐の数を $N_{\text{branch}}$、各分岐の深さを $\mathrm{depth}$ とすれば、探索コストは

                            $$\mathrm{Cost}_{\text{search}} = \lambda N_{\text{branch}} + \mu \sum_{i=1}^{N_{\text{branch}}} d_i$$

                            の形で定義できる。ここで $d_i$ は $i$ 番目の分岐の深さである。さらに情報理論的視点から候補集合の不確実性を定量化することができる。セル $v$ の候補集合 $D(v)$ に対して、候補 $d \in D(v)$ の出現確率を $p_d$ とすれば、エントロピーは

                            $$H(v) = -\sum_{d \in D(v)} p_d \log p_d$$

                            と定義される。この値は候補の散らばり具合を測る尺度であり、推論によって候補数が減少するごとに $H(v)$ も減少する。したがって各ステップにおける情報削減量 $\Delta H_t$ を評価し、それを総和することによって盤面全体の「情報収束度」を定量化できる。効率よく候補が削減されるほど $\Delta H_t$ は大きく、解読は容易であると解釈できる。以上を総合すると、数独の難易度は単なる主観的感覚ではなく、論理的コスト、探索コスト、情報削減の三要素から構成される形式的指標として定義できる。その具体形は

                            $$D = \alpha\ C_{\text{logic}} + \beta\ C_{\text{search}} - \gamma \sum_{t=1}^{T} \Delta H_t$$

                            で与えられる。ここで $C_{\text{logic}}$ は推論規則の適用に伴う論理的コスト、 $C_{\text{search}}$ は仮置きやバックトラックに基づく探索コスト、 $\Delta H_t$ は第 $t$ ステップにおける情報量削減、 $T$ は推論過程の全ステップ数を表す。また $\alpha,\beta,\gamma$ は実験的に決定される重みであり、既存の問題集に対して回帰的に最適化される。こうして得られた $D$ は、問題を難易度クラス（Easy, Medium, Hard, Expert など）に分類する客観的な基準として機能し、ユーザが問題を選択する際の有効な指標となる。
                        </div>

                        <h2 id="6-puzzle-generation">6. <ruby>問題生成<rt>もんだいせいせい</rt></ruby>と<ruby>一意性保証<rt>いちいせいほしょう</rt></ruby></h2>
                        <div class="para">
                            数独の問題生成における本質的な課題は、任意に配置された初期値の集合から出発するのではなく、あらかじめ整合的な完全解を構築したうえで、そこから与え値を削除しつつ常に一意解性を保持するという「逆問題」として定式化される点にある。完全盤 $\sigma$ はまず制約充足アルゴリズムによって生成され、これにより全てのセルが充足条件を満たすことが保証される。この完全盤から出発し、与え値の集合 $G \subseteq V$ を初期状態として保持する。すなわち最初は $G = V$ であり、全てのセルに値が埋め込まれている。生成アルゴリズムは $G$ から逐次的に要素を削除する操作を繰り返す。ただし重要なのは、削除のたびに「削除後の盤面が依然として一意解性を有するか」を必ず検証する点である。一意性が保持される場合に限り削除を確定し、保持されない場合には削除を棄却する。この反復過程によって、最終的に最小限の与え値を持つが一意解性を保つ問題が得られる。ここで核心となるのが一意性判定のアルゴリズムである。これは exact cover 問題に還元される。すなわち $729 \times 324$ の疎行列を構築し、729 行は「セル $(r,c)$ に数字 $d$ を配置する」という可能な割当を表し、324 列は「各セルに一つの値が入る」「各行に 1 から 9 が一度ずつ現れる」「各列に 1 から 9 が一度ずつ現れる」「各ボックスに 1 から 9 が一度ずつ現れる」という四種類の制約に対応する。この行列に対して Donald Knuth によって提案された Dancing Links (DLX) アルゴリズムを適用することで exact cover を効率的に探索できる。DLX は双方向連結リストによるカラム削除・復元操作を用いるため、組合せ爆発を伴う探索をきわめて効率的に進めることができる。一意性の確認においては「二解存在検査」として DLX を動作させる。すなわち、一つの解を見つけても探索を終了せず、第二の解を発見した時点で即座に停止する。この時点で盤面は非一意であると判定され、削除操作は棄却される。これにより「解が一つしか存在しない」という条件を高効率に検証することが可能になる。さらに生成過程においては、問題の難易度を制御する仕組みが求められる。完全にランダムに与え値を削除した場合、得られる問題の難易度は制御不能であり、ユーザにとって容易すぎたり、逆に過度に難解であったりすることがある。これを防ぐために確率的探索法を導入する。代表的なのは焼きなまし法であり、ここでは現在の問題の難易度 $\mathrm{Diff}$ と目標とする難易度 $\mathrm{Diff}^*$ との差を評価する。前回の難易度との差分を考慮に入れた上で、削除操作を受容するかどうかはメトロポリス基準に従って確率的に決定される。すなわち受容確率は

                            $$p = \min \Biggl( 1,\ \exp \Biggl[ -\frac{ \bigl\lvert D - D^{\ast}\bigr\rvert - \bigl\lvert D_{\text{prev}} - D^{\ast}\bigr\rvert }{T} \Biggr] \Biggr)$$

                            で与えられる。ここで $D$ は現在の難易度指標、 $D^*$ は目標難易度、 $D_{\text{prev}}$ は直前の難易度、 $T$ は温度パラメータである。反復の進行に伴い $T$ を徐々に減少させることで、局所的最適解に陥ることを避けつつ、大域的に所望の難易度へと収束させることができる。この確率的手続きを繰り返すことにより、生成される問題は常に一意解性を保持しながら、目標とする難易度に漸近する。したがって本方式によって得られる数独問題は、単に解を持つだけでなく、難易度が設計者の意図に適合するよう調整される。利用者はこれにより、容易な問題から高度に難解な問題まで、自らの学習目的や娯楽的要求に応じて選択・生成することが可能となる。
                        </div>

                        <h2 id="7-gui-visualization">7. GUIと<ruby>可視化<rt>かしか</rt></ruby></h2>
                        <div class="para">
                            数独解読アルゴリズムを数理的基盤の上に構築する際、その成果をユーザに提示するインターフェース設計は単なる視覚的補助の域を超え、むしろ推論の正統性を保証し、制約充足過程の可視的証跡を与えるという学術的意義を帯びる。数独盤面は形式上 $9\times 9$ の有限格子にすぎないが、その背後には全単射制約、候補集合の逐次縮約、矛盾検出という複雑な論理的機構が潜在しており、これらをどのように人間の直観に訴えかけるかが応用的観点からは決定的である。すなわち GUI の設計は、アルゴリズムの内部論理と人間の認知過程との間に立つ媒介層として機能しなければならず、そのためには可視化の手法自体が数学的に整合し、かつ解読の進行を忠実に反映する必要がある。まず最も基礎的な水準において、選択されたセルを基準にその行・列・ボックスに属するセルを同系統の彩色で強調することが求められる。この操作は形式的には all-different 制約の視覚的写像に相当する。すなわち集合

                            $$\lbrace x_{r,j} \mid j=1,\dots,9 \rbrace, \quad \lbrace x_{i,c} \mid i=1,\dots,9 \rbrace$$

                            さらに $3\times 3$ ブロック内の変数群がすべて相異なる値を取らなければならないという制約を、抽象的な論理式から色彩空間への埋め込みによって直観的に把握可能とするのである。これは単に操作性を補助するのみならず、制約充足問題における局所的一貫性を可視的に体現するものにほかならない。さらに、特定の数値 $d$ に関して確定済みのセルを集合 $S_d = \{(r,c)\mid x_{r,c} = d\}$ と定義し、これらを同一の強調色で表示するならば、盤面における $d$ の分布は一目で捉えられる。加えて候補集合 $C_{r,c}$ に $d$ を含むセルを淡色で示すことにより、 $d$ の潜在的配置領域が視覚的に重ね合わされる。これにより「このブロックには $d$ がまだ配置されていない」「この行では候補が一つに絞られつつある」といった推論が、形式的には単純な集合演算で表されるものを、視覚的直観として即座に呼び起こすことができる。矛盾検出においては、ユニット内部で同一数の候補が過剰に分布する場合、すなわち局所的な制約不一致の兆候が認められるときに、赤色や熱量分布の形式で視覚的警告を与えることが有効である。これは制約充足問題の枠組みにおける不可解集合の出現を、人間に理解しやすい形に翻訳したものであり、論理的一貫性の維持がどの箇所で危殆に瀕しているかを明瞭にする。こうした可視化は単なるデバッグ機能ではなく、解読アルゴリズムが論理的に進行しているか否かを外部に対して説明責任を果たすための学術的手段に等しい。特に重要なのは段階的解読の過程を逐次的に可視化する仕組みである。たとえば唯一候補 (singleton) の縮約作用素が適用される場合、形式的には $\lvert C_{r,c}\rvert = 1 \implies x_{r,c}$ が確定するという単純な推論規則にすぎないが、GUI 上においては対象セルを点滅や枠線強調によって際立たせ、さらに根拠となった候補集合の構造を示すことで、論理的証跡を可視的に提示することができる。このようにしてユーザは、単に結果を与えられるのではなく、逐次的な数理的縮約を追体験することになる。結果として、アルゴリズムはブラックボックスではなくホワイトボックスとして機能し、その透明性は教育的価値へと転化する。総じて言えば、数独解読における GUI と可視化の設計は、単なる操作性向上のための付加機能ではなく、制約充足の理論的構造を人間の認知様式に翻訳するための不可欠の学術的装置である。数理的な論理展開を可視化により表象することによって、アルゴリズムの信頼性は保証され、ユーザは推論の進行を逐一理解することができる。すなわち可視化とは、解読過程の数学的透明性を担保すると同時に、教育的応用の可能性を最大限に拡張するための方法論的基盤であると言わねばならない。
                        </div>

                        <h2 id="8-core-api">8. Core API の設計</h2>
                        <div class="para">
                            数独解読における数理的推論エンジンとユーザインターフェースを接続するためには、両者の関心領域を厳密に分離しつつも、双方向的な情報伝達を可能にする抽象層として Core API を設計することが必須となる。この API の本質的役割は、解読アルゴリズムが生成する内部的推論構造を、GUI が視覚的証跡として忠実に再構成できる形式へと翻訳する点にある。したがって、盤面状態、候補集合、推論ステップ、探索分岐といった数学的対象を、厳格に定義された抽象データ型として外部に提示することが求められる。内部表現としては、各セルの候補集合を $9$ ビットのマスクに写像し、さらに行・列・ボックス単位での使用済み数値を占有ビット列で管理する方式が最適である。しかしこれらは実装上の詳細にすぎず、外部 API では単一の `Board` 型として抽象化される。この抽象型は「セルが確定しているか」「候補がいくつ残っているか」といった問い合わせを一定の時間計算量で保証し、アルゴリズムの透明性を保ちながらも GUI 側からの不変条件の破壊を許さないよう設計されるべきである。推論規則の適用結果は `Step` 構造体として返却され、その内部には適用された規則の識別名、根拠となったセル群（証人集合）、削除された候補集合、確定された値、そして GUI 表示のための自然言語的説明文が格納される。これにより解読コアは純粋に制約理論的な縮約や探索の実行に専念しつつ、GUI 側はユーザに対して「どのセルが唯一候補であったため確定されたのか」「どの候補が矛盾により排除されたのか」といった論理的痕跡を逐次的に可視化できる。すなわち API は論理推論と可視的表現との間に明確な境界を引きながら、その両者を緊密に接続する役割を果たす。探索に関しては、関数 `solve(Board)` を再帰的に呼び出す標準的インターフェースが想定される。固定点計算によって候補削減が尽くされた後、なお未確定セルが残存する場合にのみ分岐が導入され、その過程で生成されるステップには特別に `branch` 識別子が付与される。この情報は GUI 側で明示的に提示され、論理的推論の必然性に基づく確定と、探索的仮置きによる枝分かれとを明確に区別する機能を持つ。こうして API 経由で全ての推論過程が逐一記録されることにより、難易度計算に資する定量的指標の収集や、教育的利用を目的とした学習データベースの構築が統一的な枠組みの下で可能となる。要するに、Core API は数理的制約充足系と人間中心的可視化系の境界に位置する形式的プロトコルであり、その設計如何が解読アルゴリズムの信頼性、GUI の透明性、そしてアプリケーション全体の教育的価値を決定する。抽象型と証跡構造体を中核に据えたこの設計は、数独解読を単なる計算作業から認知的・教育的営為へと昇華させるための不可欠な方法論的基盤である。
                        </div>

                        <h2 id="9-dlx-algorithm">9. 生成アルゴリズム（DLX）</h2>
                        <div class="para">
                            数独問題の生成において決定的に重要となるのは、一意解性を確実に保証するための厳密な検証手続きである。完全盤から与え値を順次削除していく操作は表面的には単純であるが、その各段階で「解がただ一つしか存在しない」という条件を満たすか否かを判定する必要がある。この判定を効率的かつ形式的に遂行するためには、Donald Knuth によって提案された Dancing Links (DLX) アルゴリズムを exact cover 問題の枠組みに適用することが最も有効である。形式化の過程としては、数独の全制約を $729 \times 324$ の二値疎行列に符号化する手順を踏む。すなわち、729 行は「セル $(r,c)$ に数字 $d$ を置く」という可能な割当を表し、324 列は四種類の制約すなわち「各セルには正確に一つの数字が入る」「各行には $1$ から $9$ が一度ずつ現れる」「各列には $1$ から $9$ が一度ずつ現れる」「各 $3\times 3$ ボックスには $1$ から $9$ が一度ずつ現れる」を反映する。あるセルに与え値が事前に指定されている場合、その候補以外の行はすべて削除され、残余の部分行列が生成される。したがって、問題の充足可能性はこの exact cover 行列の解として対応づけられる。DLX は dancing links と呼ばれる双方向連結構造を利用して列削除と復元を高速に行い、exact cover の全解を網羅的に探索するアルゴリズムである。数独における一意性判定では、DLX を「二解検出器」として用いることが肝要である。すなわち、一つの解が発見された時点で探索を停止せず、探索を継続して二つ目の解が出現した瞬間に即座に停止し「多解あり」と判定する。逆に探索を最後まで行っても二解目が見つからなければ、その問題は一意解性を有することが保証される。この仕組みによって、一意性検証は不要な探索を極限まで抑制しつつ厳密性を保持する。問題生成アルゴリズムはこの一意性判定を逐次的に適用しつつ進行する。すなわち、与え値集合から一つのセルを候補に選び、それを削除した盤面を構築する。その後 DLX によって一意性検査を実行し、依然として解が一つである場合のみ削除を確定する。もし二解目が検出されれば、その削除は棄却され、別のセルが選択される。この操作を繰り返すことで、完全盤から制約を緩めつつも常に一意解性が保持された状態が維持され、最終的に安定的に一意解数独問題を構築することが可能となる。以上の枠組みは、問題生成における「解の存在」と「解の一意性」とを明確に区別しつつ、両者を exact cover 問題の数理的形式化によって統一的に扱うものである。DLX による一意性検証は、単に効率的であるにとどまらず、生成過程全体の論理的厳密性を支える基盤技術として位置づけられる。
                        </div>

                        <h2 id="10-complexity-optimization">10. 複雑性の分析と最適化</h2>
                        <div class="para">
                            数独解読の計算複雑性を評価する場合、探索アルゴリズムの理論的計算量は本質的に指数時間であることを免れない。これは制約充足問題一般における NP 完全性の帰結であり、最悪の場合には $9^{81}$ に近い組合せ的爆発が潜在する。しかし実際の解読過程では、各セルの候補集合に対する縮約規則の反復適用が大部分の変数を初期段階で確定させるため、探索空間は指数的増大の可能性を持ちながらも実効的には劇的に縮小する。したがって平均的な実行時間は盤面の構造、初期与え値の配置、難易度に密接に依存し、単なる理論的上界では予測できない振る舞いを示す。この複雑性を実用的水準に抑制するための第一要素はデータ構造の選択である。各セルの候補集合を $9$ ビットのマスクとして表現するならば、候補削減や確定判定の演算は単一のビット演算すなわち定数時間で遂行可能となる。さらに盤面全体にわたる候補更新処理も $81$ セルに対する走査で完結するため $O(81)$、すなわち定数時間に等しい計算で済む。この手法は高水準言語である Python 実装においても十分高速に動作し、C 言語や Cython による低レベル最適化を導入すれば一桁から二桁の性能向上が期待される。探索の複雑性削減においてはヒューリスティクスの設計が決定的である。最小残余値 (MRV: Minimum Remaining Values) に基づく分岐点選択は探索木の平均深度を効果的に抑制し、分岐ごとの期待情報量を指標として採用すればさらに効率的な枝刈りが可能となる。加えて失敗駆動学習によるノーグッド集合の共有は SAT ソルバにおける conflict-driven clause learning (CDCL) の技術を応用するものであり、探索木における重複経路を劇的に排除する。この結果、理論的には指数的な探索であっても、実際の平均的複雑性は多項式的に近似可能な水準まで低減されることが多い。以上のように数独解読における効率性は、形式的な計算量解析と経験的な平均挙動の差異を正しく理解した上で、適切なデータ構造とヒューリスティクスを選択することによって初めて最適化される。理論的複雑性の峻厳さを認めつつも、実装工学的工夫により実効的な高速解読を実現することこそが、数独ソルバ設計の核心である。
                        </div>

                        <h2 id="11-testing">11. テスト規律</h2>
                        <div class="para">
                            解読システムの正当性を数学的・工学的に保証するためには、厳格に定義されたテスト規律の下で検証を行うことが不可欠である。まず基礎となるのは各推論規則に対する 健全性テストである。これは規則適用後の盤面が常に数独の全制約を保持していること、すなわち候補集合の削除や値の確定に誤謬が存在しないことを保証する試験である。この過程においては推論の局所的な正しさを担保し、単一規則レベルでの論理的一貫性を確認する。さらに規則群全体の振る舞いに関しては 可換性テストを課す必要がある。これは異なる適用順序に従った場合にも最終的に同一の固定点に収束することを検証する試験であり、推論エンジンが冪等性と安定性を有することを証明する。この検証を通じて、推論過程が順序依存的な副作用を含まないことを保証し、アルゴリズム全体の健全な振る舞いを確認する。問題生成器に関しては 一意性テスト が中心的課題となる。生成された全ての問題 $P$ に対し DLX を用いた二解検出を実施し、一意性述語 $U(P)$ が常に成立することを確認する。これにより多解を持つ不適切な問題が混入することを未然に防ぐことができる。加えて難易度評価に対しては リグレッションテストを導入し、既知の参照問題集合に対して算出される難易度指標が事前に設定された期待範囲に収まることを検証する。この仕組みによって難易度計測アルゴリズムの安定性と一貫性が長期的に維持される。最後にユーザインターフェースに対しては 整合性テスト を実施する必要がある。バックエンドから返却される推論証跡情報が GUI 上で常に正確に表現され、ユーザが論理過程を追跡可能であることを確認する。この検証は数理的正当性とユーザ体験の結合を保証するものであり、アプリケーションの教育的価値と操作的信頼性の両立に直結する。要するに、数独解読システムにおけるテスト規律は、局所的規則の健全性、規則群の可換性、生成問題の一意性、難易度指標の安定性、そして GUI 表現の整合性という多層的構造を持たねばならない。これらの体系的試験を通じてのみ、数理的に厳密でかつユーザに信頼される解読環境が構築されるのである。
                        </div>

                        <h2 id="12-conclusion">12. まとめ</h2>
                        <div class="para">
                            本稿全体を通じて、数独を有限領域制約充足問題として厳密に定式化し、その解読過程を数理的・工学的両面から体系的に論じた。推論規則は縮約作用素の不動点として理解され、健全性と停止性が保証されることを示した。また、推論のみでは盤面の完全決定に至らない場合に探索を導入し、最小残余値 (MRV) や Degree、情報量に基づくヒューリスティクスを組み合わせることで探索木の効率的剪定を実現する方法を明らかにした。さらに、失敗駆動学習によるノーグッド集合の共有を適用し、探索の重複を排除することで解読の加速が可能となることを示した。難易度の定量化については、推論規則ごとの原価、探索コスト、情報量削減量を統合することで、一貫した尺度を構築する手法を提示した。問題生成に関しては、完全盤からの与え値削除を基盤とし、Donald Knuth の Dancing Links (DLX) アルゴリズムによる一意性判定を随伴させることで、一解性を厳密に保証した。さらに焼きなまし法など確率的探索法を組み合わせることで、目標難易度に収束させる生成アルゴリズムの構成を論じた。これらにより、生成される問題は厳密な一意性を保持しつつ、所望の難易度分布を実現することが可能となる。加えて GUI による可視化の設計が、数理的推論の透明性を保証し、ユーザに推論過程を追体験させる教育的効果をもたらすことを論じた。行・列・ボックスの制約構造、数値分布、候補集合の縮約過程、矛盾検出の警告表示、そして段階解読における証跡の逐次的提示が、直観的理解を促進するインターフェースとして位置づけられる。以上を総合すれば、SudokuResolver は、数理的基盤に支えられた解読コア、形式的に定義された難易度評価体系、DLX に基づく厳密な一意性保証を備えた問題生成器、そして透明性と教育的価値を重視した GUI を統合する総合的システムである。この設計は単なる娯楽的ツールを超えて、制約充足問題の実用的応用、数理的推論教育の教材、さらには人間型推論と計算機推論との交錯を観察する実験的プラットフォームとして学術的意義を持つものである。
                        </div>

                        <h2 id="references">参考文献</h2>
                        <ul class="references">
                            <li id="ref-yato-seta-2003">
                                Yato, T., &amp; Seta, T. (2003).
                                <em>Complexity and Completeness of Finding Another Solution and Its Application to Puzzles</em>.
                                <cite>IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences</cite>,
                                E86-A(5), 1052–1060.
                            </li>
                            
                            <li id="ref-tarski-1955">
                                Tarski, A. (1955).
                                <em>A lattice-theoretical fixpoint theorem and its applications</em>.
                                <cite>Pacific Journal of Mathematics</cite>, 5(2), 285–309.
                            </li>
                            
                            <li id="ref-kleene-1952">
                                Kleene, S. C. (1952).
                                <em>Introduction to Metamathematics</em>.
                                <cite>North-Holland</cite>.
                            </li>
                        </ul>
                    </article>
                </div>
            </section>
        </main>

        <!-- JS で勝手に追加してくれるが、予備的に footer を追加しておく -->
        <div id="sr-footer"></div>

        <script src="/docs/js/animations/modules/scrollreveal.min.js" defer></script>
        <script src="https://cdn.jsdelivr.net/npm/animejs/lib/anime.iife.min.js" defer></script>
        <script src="/docs/js/animations/modules/swiper-bundle.min.js" defer></script>

        <script src="/docs/js/animations/anime-js.js" defer></script>
        <script src="/docs/js/animations/swiper-js.js" defer></script>
        <script src="/docs/js/animations/scrollreveal-js.js" defer></script>
    </div>
</body>

</html>